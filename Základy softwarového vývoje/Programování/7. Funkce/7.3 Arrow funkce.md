
---

## âš¡ ZÃ¡kladnÃ­ syntaxe

Arrow funkce umoÅ¾ÅˆujÃ­ velmi krÃ¡tkÃ½ zÃ¡pis funkÄnÃ­ho vÃ½razu.
- **ZkrÃ¡cenÃ¡ forma s implicitnÃ­m nÃ¡vratem:**

```javascript
let func = (arg1, arg2) => vÃ½raz;
```

VrÃ¡tÃ­ vÃ½sledek vyhodnocenÃ­ vÃ½razu napravo odÂ `=>`.
- **Ekvivalent s Function Expression:**

```javascript
let func = function (arg1, arg2) {
return vÃ½raz;
};
```

>[!example] PÅ™Ã­klady pouÅ¾itÃ­
>
>- **Dva argumenty (ZÃ¡vorky jsou povinnÃ©):**
> 
>```javascript
>let sum = (a, b) => a + b;
>```
>
>- **Jeden argument (ZÃ¡vorky lze vynechat):**
>
>```javascript
>let double = n => n * 2;
>```
>
>- **Bez argumentÅ¯ (PrÃ¡zdnÃ© zÃ¡vorky jsou povinnÃ©):**
>
>```javascript
>let sayHi = () => "Hello!";
  >  ```

---

## ğŸ¯ BlokovÃ© tÄ›lo vs. implicitnÃ­ nÃ¡vrat

ZpÅ¯sob, jakÃ½m funkce vracÃ­ hodnotu, zÃ¡visÃ­ na pouÅ¾itÃ­ sloÅ¾enÃ½ch zÃ¡vorek.

### 1. ImplicitnÃ­ nÃ¡vrat (Single-line)
PouÅ¾Ã­vÃ¡ se bez sloÅ¾enÃ½ch zÃ¡vorek (`{}`). VÃ½sledek vÃ½razu je automaticky vrÃ¡cen.

```javascript
let inc = (x) => x + 1; // automaticky vracÃ­ x + 1
```

### 2. BlokovÃ© tÄ›lo (Multi-line)
PouÅ¾Ã­vÃ¡ sloÅ¾enÃ© zÃ¡vorky (`{}`) pro vÃ­ce pÅ™Ã­kazÅ¯.Â **VyÅ¾aduje**Â explicitnÃ­Â `return`.

```javascript
let sum = (a, b) => {
    const r = a + b;
    return r; // V bloku je nutnÃ© pouÅ¾Ã­t return
};
```

### 3. VrÃ¡cenÃ­ objektovÃ©ho literÃ¡lu
Pokud chcete implicitnÄ› vrÃ¡tit objekt,Â **musÃ­te ho uzavÅ™Ã­t do kulatÃ½ch zÃ¡vorek**Â `()`Â â€“ jinak se sloÅ¾enÃ© zÃ¡vorkyÂ `{}`Â interpretujÃ­ jako blok kÃ³du.

```javascript
// SprÃ¡vnÄ›: vracÃ­ objekt { name: "Jan", active: true }
let makeUser = (name) => ({ name, active: true }); 
```

---

## âš ï¸ OmezenÃ­: Kde se arrow functions nehodÃ­

Arrow funkce majÃ­Â **lexikÃ¡lnÃ­**Â (statickÃ©) urÄenÃ­ kontextu a postrÃ¡dajÃ­ nÄ›kterÃ© vlastnosti tradiÄnÃ­ch funkcÃ­.

- **Å½Ã¡dnÃ© vlastnÃ­Â `this`:** `this`Â seÂ **dÄ›dÃ­ z okolnÃ­ho (lexikÃ¡lnÃ­ho) kontextu**. Nejsou vhodnÃ© jakoÂ **metody objektÅ¯**, kde oÄekÃ¡vÃ¡te, Å¾eÂ `this`Â bude odkazovat na samotnÃ½ objekt (dynamickÃ½Â `this`).

```javascript
const obj = {
x: 1,
getX: () => this.x, // Zde this odkazuje na globÃ¡lnÃ­ objekt (window), ne na obj
};
```

- **Å½Ã¡dnÃ©Â `arguments`:** NemajÃ­ vlastnÃ­ promÄ›nnouÂ `arguments`, kterÃ¡ by obsahovala vÅ¡echny pÅ™edanÃ© argumenty.
- **Å˜eÅ¡enÃ­:**Â PouÅ¾ijteÂ **zbytkovÃ© parametry**Â (`...args`).

```javascript
const sum = (...args) => args.reduce((a, b) => a + b, 0); 
```

- **Nelze jako konstruktory:** Nelze je volat s klÃ­ÄovÃ½m slovemÂ `new`. NemajÃ­Â `prototype`.

```javascript
const Foo = () => {};
// new Foo() // âŒ TypeError
```

- **Nelze pouÅ¾Ã­t sÂ `yield`:**Â Arrow funkce nemohou bÃ½t generÃ¡tory.

---

## ğŸ’¡ PodmÃ­nÄ›nÃ© pÅ™iÅ™azenÃ­ funkce

Arrow funkce jsou skvÄ›lÃ© pro krÃ¡tkou implementaci funkcÃ­ v podmÃ­nÄ›nÃ½ch vÃ½razech:

```javascript
const age = 18;
// PÅ™iÅ™adÃ­ sprÃ¡vnou implementaci podle podmÃ­nky (TernÃ¡rnÃ­ operÃ¡tor)
const welcome = age < 18 ? () => "Hello!" : () => "Greetings!"; 

welcome(); // "Greetings!"
```

---

## ğŸ“‹ ShrnutÃ­

- **KrÃ¡tkÃ½ zÃ¡pis (implicitnÃ­ nÃ¡vrat):**Â `(...args) => vÃ½raz`
- **VÃ­ce pÅ™Ã­kazÅ¯ (explicitnÃ­ nÃ¡vrat):**Â `(...args) => { ... return hodnota; }`
- **VrÃ¡cenÃ­ objektu:**Â VyÅ¾aduje zÃ¡vorky:Â `(name) => ({ name: name })`
- **VhodnÃ© pro:**Â JednoduchÃ©Â **callbacky**Â a krÃ¡tkÃ© funkce (ÄitelnÃ©).
- **OmezenÃ­:**Â **Nelze**Â je pouÅ¾Ã­t jako metody objektÅ¯, konstruktory nebo pro pÅ™Ã­stup kÂ `arguments`.